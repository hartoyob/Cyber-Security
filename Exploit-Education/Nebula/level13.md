# level13

## Challenge info

There is a security check that prevents the program from continuing execution if the user invoking it does not match a specific user id.

```
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <sys/types.h>
#include <string.h>

#define FAKEUID 1000

int main(int argc, char **argv, char **envp)
{
  int c;
  char token[256];

  if(getuid() != FAKEUID) {
      printf("Security failure detected. UID %d started us, we expect %d\n", getuid(), FAKEUID);
      printf("The system administrators will be notified of this violation\n");
      exit(EXIT_FAILURE);
  }

  // snip, sorry :)

  printf("your token is %s\n", token);
  
}
```
## Solution
First thing i tried was using strings and the token is there (but it's probably encrypted), then tried gdb and alter the program counter to see if there was any thing working behind to bring the token up...
Suprisingly no checks for debug mode, the token is printed right away just by seting the pc to the printf address.

```
set $pc = 0x08048531
c
your token is: b705702b-76a8-42b0-8844-3adabbe5ac58
```

Now just su to flag 13 and get the flag

```
su flag13
Password: (token here)
whoami 
flag13
```
## Flag
```
You have successfully executed getflag on a target account
```